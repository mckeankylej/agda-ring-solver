
@inproceedings{rivas_monoids_2015,
  langid = {english},
  title = {From Monoids to Near-Semirings: The Essence of {{MonadPlus}} and {{Alternative}}},
  isbn = {978-1-4503-3516-4},
  url = {http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf},
  doi = {10.1145/2790449.2790514},
  shorttitle = {From Monoids to Near-Semirings},
  abstract = {It is well-known that monads are monoids in the category of endo-functors, and in fact so are applicative functors. Unfortunately, the benefits of this unified view are lost when the additional non-determinism structure of |MonadPlus| or |Alternative| is required.

This article recovers the essence of these two type classes by extending monoids to near-semirings with both additive and multiplicative structure. This unified algebraic view enables us to generically define the free construction as well as a novel double Cayley representation that optimises both left-nested sums and left-nested products.},
  booktitle = {Proceedings of the 17th {{International Symposium}} on {{Principles}} and {{Practice}} of {{Declarative Programming}}},
  publisher = {{ACM}},
  urldate = {2016-11-23},
  date = {2015},
  pages = {196-207},
  author = {Rivas, Exequiel and Jaskelioff, Mauro and Schrijvers, Tom},
  file = {/Users/doisinkidney/Zotero/storage/TQ2SUXE7/Rivas et al. - From monoids to near-semirings the essence of Mon.pdf},
  note = {https://www.reddit.com/r/haskell/comments/3dlz6b/from\_monoids\_to\_nearsemirings\_the\_essence\_of/?}
}

@inproceedings{jones_call-pattern_2007,
  langid = {english},
  title = {Call-Pattern Specialisation for Haskell Programs},
  isbn = {978-1-59593-815-2},
  url = {https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/},
  doi = {10.1145/1291151.1291200},
  abstract = {User-deﬁned data types, pattern-matching, and recursion are ubiquitous features of Haskell programs. Sometimes a function is called with arguments that are statically known to be in constructor form, so that the work of pattern-matching is wasted. Even worse, the argument is sometimes freshly-allocated, only to be immediately decomposed by the function.},
  publisher = {{ACM Press}},
  urldate = {2018-03-21},
  date = {2007},
  pages = {327},
  author = {Jones, Simon Peyton},
  file = {/Users/doisinkidney/Zotero/storage/JMQ9HUQK/Jones - 2007 - Call-pattern specialisation for haskell programs.pdf;/Users/doisinkidney/Zotero/storage/MBT8QXM2/Jones - 2007 - Call-pattern specialisation for Haskell programs.pdf;/Users/doisinkidney/Zotero/storage/U38CF3T4/system-f-with-type-equality-coercions-2.html}
}

@article{mcbride_polynomial_nodate,
  langid = {english},
  title = {A Polynomial Testing Principle},
  abstract = {Two polynomial functions of degree at most n agree on all inputs if they agree on n + 1 diﬀerent inputs, e.g., on \{0, 1, 2, . . . , n\}. This fact gives us a simple procedure for testing equivalence in a language of polynomial expressions. Moreover, we may readily extend this language to include a summation operator and test standard results which are usually established inductively.},
  pages = {14},
  author = {McBride, Conor},
  file = {/Users/doisinkidney/Zotero/storage/TJY6RASV/McBride - A polynomial testing principle.pdf}
}

@inproceedings{cheng_functional_2018,
  langid = {english},
  title = {Functional {{Pearl}}: {{Folding Polynomials}} of {{Polynomials}}},
  isbn = {978-3-319-90685-0 978-3-319-90686-7},
  url = {https://link.springer.com/chapter/10.1007/978-3-319-90686-7_5},
  doi = {10.1007/978-3-319-90686-7_5},
  shorttitle = {Functional {{Pearl}}},
  abstract = {Polynomials are a central concept to many branches in mathematics and computer science. In particular, manipulation of polynomial expressions can be used to model a wide variety of computation. In this paper, we consider a simple recursive construction of multivariate polynomials over a base ring such as the integers or a (finite) field. We show that this construction allows inductive implementation of polynomial operations such as arithmetic, evaluation, substitution, etc. Furthermore, we can transform a polynomial expression into in a sequence of arithmetic expressions in the base ring and prove the correctness of this transformation in Agda. Combined with our recursive construction, this allows for compiling polynomial expressions over a tower of extension fields into scalar expressions over the ground field, for example. Such a technique is not only interesting in its own right but also finds plentiful application in research areas such as cryptography.},
  eventtitle = {International {{Symposium}} on {{Functional}} and {{Logic Programming}}},
  booktitle = {Functional and {{Logic Programming}}},
  series = {Lecture Notes in Computer Science},
  publisher = {{Springer, Cham}},
  urldate = {2018-08-02},
  date = {2018-05-09},
  pages = {68-83},
  author = {Cheng, Chen-Mou and Hsu, Ruey-Lin and Mu, Shin-Cheng},
  file = {/Users/doisinkidney/Zotero/storage/D8GT5G46/Cheng et al. - 2018 - Functional Pearl Folding Polynomials of Polynomia.pdf;/Users/doisinkidney/Zotero/storage/CYZ5CHC3/978-3-319-90686-7_5.html}
}

@inproceedings{hutchison_proving_2005,
  langid = {english},
  location = {{Berlin, Heidelberg}},
  title = {Proving {{Equalities}} in a {{Commutative Ring Done Right}} in {{Coq}}},
  volume = {3603},
  isbn = {978-3-540-28372-0 978-3-540-31820-0},
  url = {http://link.springer.com/10.1007/11541868_7},
  doi = {10.1007/11541868_7},
  abstract = {We present a new implementation of a reﬂexive tactic which solves equalities in a ring structure inside the Coq system. The eﬃciency is improved to a point that we can now prove equalities that were previously beyond reach. A special care has been taken to implement eﬃcient algorithms while keeping the complexity of the correctness proofs low. This leads to a single tool, with a single implementation, which can be addressed for a ring or for a semi-ring, abstract or not, using the Leibniz equality or a setoid equality. This example shows that such reﬂective methods can be eﬀectively used in symbolic computation.},
  eventtitle = {International {{Conference}} on {{Theorem Proving}} in {{Higher Order Logics}}},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  series = {Lecture Notes in Computer Science},
  publisher = {{Springer Berlin Heidelberg}},
  urldate = {2018-08-03},
  date = {2005},
  pages = {98-113},
  author = {Grégoire, Benjamin and Mahboubi, Assia},
  editor = {Hurd, Joe and Melham, Tom},
  editorb = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard},
  editorbtype = {redactor},
  file = {/Users/doisinkidney/Zotero/storage/GTPFHWSU/Grégoire and Mahboubi - 2005 - Proving Equalities in a Commutative Ring Done Righ.pdf;/Users/doisinkidney/Zotero/storage/KK2HQB4Z/11541868_7.html}
}

@article{gumundsson_formalizing_2017,
  langid = {english},
  title = {Formalizing the Translation Method in {{Agda}}},
  abstract = {If ������ and ������ are sets of combinatorial objects, the translation method, introduced by Wood and Zeilberger (2009), allows one to turn an algebraic proof of the identity |������ | = |������| into a bijection between ������ and ������. We give a formalized implementation of the translation method in the programming language Agda. In contrast to the implementation previously given by Wood and Zeilberger, the bijections produced by our implementation are formally verified, making our implementation more robust. We also take advantage of the fact that Agda is a proof assistant, allowing users of our implementation to use the existing facilities provided by Agda for developing proofs. In particular, converting an existing algebraic proof for use in our implementation is often straightforward.},
  date = {2017-06},
  pages = {112},
  author = {Guðmundsson, Bjarki Ágúst},
  file = {/Users/doisinkidney/Zotero/storage/IHJEUPEG/Guðmundsson - Formalizing the translation method in Agda.pdf}
}

@article{johnson_sparse_1974,
  langid = {english},
  title = {Sparse Polynomial Arithmetic},
  volume = {8},
  issn = {01635824},
  url = {http://portal.acm.org/citation.cfm?doid=1086837.1086847},
  doi = {10.1145/1086837.1086847},
  abstract = {Sparse polynomial representations are used in a number of algebraic manipulation systems, including Aitran. This paper discusses the arithmetic operations with sparsely represented polynomials; we give particular attention to multiplication and division• We give new algorithms for multiplying two polynomials, with n and m terms, in time mnlogm; these algorithms have the property that, in the usual univariate dense case, the algorithm is bounded by ran. Division algorithms are discussed which run in comparable time.},
  number = {3},
  journaltitle = {ACM SIGSAM Bulletin},
  urldate = {2018-08-07},
  date = {1974-08-01},
  pages = {63-71},
  author = {Johnson, Stephen C.},
  file = {/Users/doisinkidney/Zotero/storage/N574968I/Johnson - 1974 - Sparse polynomial arithmetic.pdf}
}

@article{meshveliani_dependent_nodate,
  langid = {english},
  title = {Dependent {{Types}} for an {{Adequate Programming}} of {{Algebra}}},
  abstract = {This research compares the author’s experience in programming algebra in Haskell and in Agda (currently the former experience is large, and the latter is small). There are discussed certain hopes and doubts related to the dependently typed and veriﬁed programming of symbolic computation. This concerns the 1) author’s experience history, 2) algebraic class hierarchy design, 3) proof cost overhead in evaluation and in coding, 4) other subjects. Various examples are considered.},
  pages = {15},
  author = {Meshveliani, Sergei D},
  file = {/Users/doisinkidney/Zotero/storage/SESGEH6A/Meshveliani - Dependent Types for an Adequate Programming of Alg.pdf}
}

@online{noauthor_s._nodate,
  title = {S.~{{D}}.~{{Meshveliani}}, “{{Programming}} Basic Computer Algebra in a Language with Dependent Types”, {{Program Systems}}: {{Theory}} and {{Applications}}, 6:4 (2015), 313–340},
  url = {http://www.mathnet.ru/php/archive.phtml?wshow=paper&jrnid=ps&paperid=190&option_lang=eng},
  urldate = {2018-08-07},
  file = {/Users/doisinkidney/Zotero/storage/AVB6TJEI/archive.html}
}

@article{paulson_future_nodate,
  langid = {english},
  title = {The {{Future}} of {{Formalised Mathematics}}},
  pages = {35},
  author = {Paulson, Lawrence C},
  file = {/Users/doisinkidney/Zotero/storage/R9S6SV6Y/Paulson - The Future of Formalised Mathematics.pdf}
}

@thesis{zalakain_evidence-providing_2017,
  langid = {english},
  location = {{Strathclyde}},
  title = {Evidence-Providing Problem Solvers in {{Agda}}},
  url = {https://umazalakain.info/static/report.pdf},
  abstract = {The Curry-Howard correspondence draws a direct link between logic and computation: propositions are modelled as types and proofs as programs; to prove a proposition is to con- struct a program inhabiting its corresponding type. Several computer-assisted theorem provers have been developed under this idea. They are not just used to verify human reasoning: they are also often capable of generating proofs automatically.
This project considers the development of such automated theorem provers in Agda, a de- pendently typed programming language. As a warm-up, I present a verified solver for equations on monoids. Then, I comment on the solver for commutative rings included in Agda’s stan- dard library. Finally, I develop a verified decision procedure for Presburger arithmetic — a decidable first-order predicate logic.},
  institution = {{University of Strathclyde}},
  type = {Submitted for the Degree of B.Sc. in Computer Science},
  urldate = {2018-03-08},
  date = {2017/2018},
  author = {Zalakain, Uma},
  file = {/Users/doisinkidney/Zotero/storage/HK3IVT32/report.pdf}
}

@incollection{geuvers_automatically_2017,
  langid = {english},
  location = {{Cham}},
  title = {Automatically {{Proving Equivalence}} by {{Type}}-{{Safe Reflection}}},
  volume = {10383},
  isbn = {978-3-319-62074-9 978-3-319-62075-6},
  url = {http://link.springer.com/10.1007/978-3-319-62075-6_4},
  abstract = {One diﬃculty with reasoning and programming with dependent types is that proof obligations arise naturally once programs become even moderately sized. For example, implementing an adder for binary numbers indexed over their natural number equivalents naturally leads to proof obligations for equalities of expressions over natural numbers. The need for these equality proofs comes, in intensional type theories, from the fact that the propositional equality enables us to prove as equal terms that are not judgementally equal, which means that the typechecker can’t always obtain equalities by reduction. As far as possible, we would like to solve such proof obligations automatically. In this paper, we show one way to automate these proofs by reﬂection in the dependently typed programming language Idris. We show how deﬁning reﬂected terms indexed by the original Idris expression allows us to construct and manipulate proofs. We build a hierarchy of tactics for proving equivalences in semigroups, monoids, commutative monoids, groups, commutative groups, semi-rings and rings. We also show how each tactic reuses those from simpler structures, thus avoiding duplication of code and proofs.},
  booktitle = {Intelligent {{Computer Mathematics}}},
  publisher = {{Springer International Publishing}},
  urldate = {2018-08-16},
  date = {2017},
  pages = {40-55},
  author = {Slama, Franck and Brady, Edwin},
  editor = {Geuvers, Herman and England, Matthew and Hasan, Osman and Rabe, Florian and Teschke, Olaf},
  file = {/Users/doisinkidney/Zotero/storage/PDB7LZPW/Slama and Brady - 2017 - Automatically Proving Equivalence by Type-Safe Ref.pdf},
  doi = {10.1007/978-3-319-62075-6_4}
}

@article{mu_algebra_2009,
  langid = {english},
  title = {Algebra of Programming in {{Agda}}: {{Dependent}} Types for Relational Program Derivation},
  volume = {19},
  issn = {1469-7653, 0956-7968},
  url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/algebra-of-programming-in-agda-dependent-types-for-relational-program-derivation/ACA0C08F29621A892FB0C0B745254D15},
  doi = {10.1017/S0956796809007345},
  shorttitle = {Algebra of Programming in {{Agda}}},
  abstract = {Relational program derivation is the technique of stepwise refining a relational specification to a program by algebraic rules. The program thus obtained is correct by construction. Meanwhile, dependent type theory is rich enough to express various correctness properties to be verified by the type checker. We have developed a library, AoPA (Algebra of Programming in Agda), to encode relational derivations in the dependently typed programming language Agda. A program is coupled with an algebraic derivation whose correctness is guaranteed by the type system. Two non-trivial examples are presented: an optimisation problem and a derivation of quicksort in which well-founded recursion is used to model terminating hylomorphisms in a language with inductive types.},
  number = {5},
  journaltitle = {Journal of Functional Programming},
  urldate = {2018-08-17},
  date = {2009-09},
  pages = {545-579},
  author = {Mu, Shin-Cheng and Ko, Hsiang-Shang and Jansson, Patrik},
  file = {/Users/doisinkidney/Zotero/storage/8IUG4JU2/Mu et al. - 2009 - Algebra of programming in Agda Dependent types fo.pdf;/Users/doisinkidney/Zotero/storage/D7UWNTJ4/Mu et al. - 2009 - Algebra of programming in Agda Dependent types fo.pdf;/Users/doisinkidney/Zotero/storage/D8FNYT4X/Mu et al. - 2009 - Algebra of programming in Agda Dependent types fo.pdf;/Users/doisinkidney/Zotero/storage/5D6VGKJQ/ACA0C08F29621A892FB0C0B745254D15.html}
}

@inproceedings{audebaud_algebra_2008,
  langid = {english},
  location = {{Berlin, Heidelberg}},
  title = {Algebra of {{Programming Using Dependent Types}}},
  volume = {5133},
  isbn = {978-3-540-70593-2 978-3-540-70594-9},
  url = {http://link.springer.com/10.1007/978-3-540-70594-9_15},
  doi = {10.1007/978-3-540-70594-9_15},
  abstract = {Dependent type theory is rich enough to express that a program satisfies an input/output relational specification, but it could be hard to construct the proof term. On the other hand, squiggolists know very well how to show that one relation is included in another by algebraic reasoning. We demonstrate how to encode functional and relational derivations in a dependently typed programming language. A program is coupled with an algebraic derivation from a specification, whose correctness is guaranteed by the type system.},
  eventtitle = {International {{Conference}} on {{Mathematics}} of {{Program Construction}}},
  booktitle = {Mathematics of {{Program Construction}}},
  series = {Lecture Notes in Computer Science},
  publisher = {{Springer Berlin Heidelberg}},
  urldate = {2018-08-18},
  date = {2008},
  pages = {268-283},
  author = {Mu, Shin-Cheng and Ko, Hsiang-Shang and Jansson, Patrik},
  editor = {Audebaud, Philippe and Paulin-Mohring, Christine},
  file = {/Users/doisinkidney/Zotero/storage/ASKFWFTU/Mu et al. - Algebra of Programming Using Dependent Types.pdf;/Users/doisinkidney/Zotero/storage/5VKT7DWK/10.html}
}

@online{gibbons_horners_2011,
  langid = {english},
  title = {Horner’s {{Rule}}},
  url = {https://patternsinfp.wordpress.com/2011/05/05/horners-rule/},
  abstract = {This post is about my all-time favourite calculation, of a linear-time algorithm for the maximum segment sum problem, based on Horner’s Rule. The problem was popularized in Jon Bentley’…},
  journaltitle = {Patterns in Functional Programming},
  urldate = {2018-08-19},
  date = {2011-05-05},
  author = {Gibbons, Jeremy},
  file = {/Users/doisinkidney/Zotero/storage/WRD6S87U/horners-rule.html}
}

@online{gibbons_distributivity_2011,
  langid = {english},
  title = {Distributivity in {{Horner}}’s {{Rule}}},
  url = {https://patternsinfp.wordpress.com/2011/05/17/distributivity-in-horners-rule/},
  abstract = {This is a continuation of my previous post on Horner’s Rule, and in particular, of the discussion there about distributivity in the datatype-generic version of the Maximum Segment Sum problem…},
  journaltitle = {Patterns in Functional Programming},
  urldate = {2018-08-19},
  date = {2011-05-17},
  author = {Gibbons, Jeremy},
  file = {/Users/doisinkidney/Zotero/storage/QSZZFG3P/distributivity-in-horners-rule.html}
}

@article{mcbride_view_2004,
  title = {The {{View}} from the {{Left}}},
  volume = {14},
  issn = {0956-7968},
  url = {http://strictlypositive.org/vfl.pdf},
  doi = {10.1017/S0956796803004829},
  abstract = {Pattern matching has proved an extremely powerful and durable notion in functional programming. This paper contributes a new programming notation for type theory which elaborates the notion in various ways. First, as is by now quite well-known in the type theory community, definition by pattern matching becomes a more discriminating tool in the presence of dependent types, since it refines the explanation of types as well as values. This becomes all the more true in the presence of the rich class of datatypes known as inductive families (Dybjer, 1991). Secondly, as proposed by Peyton Jones (1997) for Haskell, and independently rediscovered by us, subsidiary case analyses on the results of intermediate computations, which commonly take place on the right-hand side of definitions by pattern matching, should rather be handled on the left. In simply-typed languages, this subsumes the trivial case of Boolean guards; in our setting it becomes yet more powerful. Thirdly, elementary pattern matching decompositions have a well-defined interface given by a dependent type; they correspond to the statement of an induction principle for the datatype. More general, user-definable decompositions may be defined which also have types of the same general form. Elementary pattern matching may therefore be recast in abstract form, with a semantics given by translation. Such abstract decompositions of data generalize Wadler's (1987) notion of ‘view’. The programmer wishing to introduce a new view of a type \$$\backslash$mathit\{T\}\$, and exploit it directly in pattern matching, may do so via a standard programming idiom. The type theorist, looking through the Curry–Howard lens, may see this as proving a theorem, one which establishes the validity of a new induction principle for \$$\backslash$mathit\{T\}\$. We develop enough syntax and semantics to account for this high-level style of programming in dependent type theory. We close with the development of a typechecker for the simply-typed lambda calculus, which furnishes a view of raw terms as either being well-typed, or containing an error. The implementation of this view is ipso facto a proof that typechecking is decidable.},
  number = {1},
  journaltitle = {J. Funct. Program.},
  urldate = {2018-08-21},
  date = {2004-01},
  pages = {69--111},
  author = {McBride, Conor and McKinna, James},
  file = {/Users/doisinkidney/Zotero/storage/JPF2T4CC/McBride and McKinna - 2004 - The View from the Left.pdf}
}

@report{russino_polynomial_2017,
  langid = {english},
  title = {Polynomial {{Terms}} and {{Sparse Horner Normal Form}}},
  url = {http://www.russinoff.com/papers/shnf.pdf},
  date = {2017-07-20},
  pages = {8},
  author = {Russinoﬀ, David M},
  file = {/Users/doisinkidney/Zotero/storage/XGCQCLFR/Russinoﬀ - Polynomial Terms and Sparse Horner Normal Form.pdf}
}

@online{mcbride_polynomial_2018,
  langid = {english},
  title = {A {{Polynomial Testing Principle}}},
  url = {https://twitter.com/pigworker/status/1013535783234473984},
  abstract = {A polynomial testing principle gives a machine-checked proof that, under suitably controlled circumstances, in a small but familiar domain, testing can reveal the absence of bugs.},
  journaltitle = {Conor McBride's Twitter Feed},
  type = {Tweet},
  urldate = {2018-08-23},
  date = {2018-07-01},
  author = {McBride, Conor},
  file = {/Users/doisinkidney/Zotero/storage/DB4NV3DI/1013535783234473984.html}
}

@inproceedings{kiselyov_extensible_2013-2,
  langid = {english},
  location = {{New York, NY, USA}},
  title = {Extensible {{Effects}}: {{An Alternative}} to {{Monad Transformers}}},
  isbn = {978-1-4503-2383-3},
  url = {http://okmij.org/ftp/Haskell/extensible/},
  doi = {10.1145/2503778.2503791},
  shorttitle = {Extensible {{Effects}}},
  abstract = {We design and implement a library that solves the long-standing problem of combining effects without imposing restrictions on their interactions (such as static ordering). Effects arise from interactions between a client and an effect handler (interpreter); interactions may vary throughout the program and dynamically adapt to execution conditions. Existing code that relies on monad transformers may be used with our library with minor changes, gaining efficiency over long monad stacks. In addition, our library has greater expressiveness, allowing for practical idioms that are inefficient, cumbersome, or outright impossible with monad transformers. Our alternative to a monad transformer stack is a single monad, for the coroutine-like communication of a client with its handler. Its type reflects possible requests, i.e., possible effects of a computation. To support arbitrary effects and their combinations, requests are values of an extensible union type, which allows adding and, notably, subtracting summands. Extending and, upon handling, shrinking of the union of possible requests is reflected in its type, yielding a type-and-effect system for Haskell. The library is lightweight, generalizing the extensible exception handling to other effects and accurately tracking them in types.},
  booktitle = {Proceedings of the 2013 {{ACM SIGPLAN Symposium}} on {{Haskell}}},
  series = {Haskell '13},
  publisher = {{ACM}},
  urldate = {2018-08-24},
  date = {2013},
  pages = {59--70},
  keywords = {Effects,Haskell,coroutine,effect handler,effect interaction,monad,monad transformer,open union,type and effect system},
  author = {Kiselyov, Oleg and Sabry, Amr and Swords, Cameron},
  file = {/Users/doisinkidney/Zotero/storage/PDUC9QH6/exteff.pdf;/Users/doisinkidney/Zotero/storage/XTZHSAEH/Kiselyov et al. - 2013 - Extensible Effects An Alternative to Monad Transf.pdf}
}

@article{coquand_isomorphism_2013,
  langid = {english},
  title = {Isomorphism Is Equality},
  volume = {24},
  issn = {00193577},
  url = {http://www.cse.chalmers.se/~nad/publications/coquand-danielsson-isomorphism-is-equality.html},
  doi = {10.1016/j.indag.2013.09.002},
  abstract = {The setting of this work is dependent type theory extended with the univalence axiom. We prove that, for a large class of algebraic structures, isomorphic instances of a structure are equal—in fact, isomorphism is in bijective correspondence with equality. The class of structures includes monoids whose underlying types are “sets”, and also posets where the underlying types are sets and the ordering relations are pointwise “propositional”. For monoids on sets equality coincides with the usual notion of isomorphism from universal algebra, and for posets of the kind mentioned above equality coincides with order isomorphism.},
  number = {4},
  journaltitle = {Indagationes Mathematicae},
  urldate = {2018-08-25},
  date = {2013-11},
  pages = {1105-1120},
  author = {Coquand, Thierry and Danielsson, Nils Anders},
  file = {/Users/doisinkidney/Zotero/storage/8X25PWGE/Coquand and Danielsson - 2013 - Isomorphism is equality.pdf}
}

@thesis{lioubartsev_constructing_nodate,
  title = {Constructing a {{Computer Algebra System Capable}} of {{Generating Pedagogical Step}}-by-{{Step Solutions}}},
  abstract = {For the problem of producing pedagogical step-by-step so- lutions to mathematical problems in education, standard methods and algorithms used in construction of computer algebra systems are often not suitable. A method of us- ing rules to manipulate mathematical expressions in small steps is suggested and implemented. The problem of creat- ing a step-by-step solution by choosing which rule to apply and when to do it is redefined as a graph search problem and variations of the A* algorithm are used to solve it. It is all put together into one prototype solver that was evalu- ated in a study. The study was a questionnaire distributed among high school students. The results showed that while the solutions were not as good as human-made ones, they were competent. Further improvements of the method are suggested that would probably lead to better solutions.},
  institution = {{KTH Royal Institue of Technology}},
  author = {Lioubartsev, Dmitrij},
  file = {/Users/doisinkidney/Zotero/storage/2Z62FSZP/FULLTEXT01.pdf}
}

@article{wood_translation_2009,
  langid = {english},
  title = {A {{Translation Method}} for {{Finding Combinatorial Bijections}}},
  volume = {13},
  issn = {0219-3094},
  url = {https://doi.org/10.1007/s00026-009-0024-y},
  doi = {10.1007/s00026-009-0024-y},
  abstract = {Consider a combinatorial identity that can be proved by induction. In this paper, we describe a general method for translating the inductive proof into a recursive bijection. Furthermore, we will demonstrate that the resulting recursive bijection can often be defined in a direct, non-recursive way. Thus, the translation method often results in a bijective proof of the identity that helps illuminate the underlying combinatorial structures. This paper has two main parts: First, we describe the translation method and the accompanying Maple code; and second, we give a few examples of how the method has been used to discover new bijections.},
  number = {3},
  journaltitle = {Annals of Combinatorics},
  shortjournal = {Ann. Comb.},
  urldate = {2018-08-29},
  date = {2009-10-23},
  pages = {383},
  keywords = {05A19,bijection,bijective proof,combinatorial identity},
  author = {Wood, Philip Matchett and Zeilberger, Doron},
  file = {/Users/doisinkidney/Zotero/storage/6UJ9BBPT/Wood and Zeilberger - 2009 - A Translation Method for Finding Combinatorial Bij.pdf}
}

@thesis{van_der_walt_reflection_2012,
  title = {Reflection in {{Agda}}},
  type = {Master's Thesis},
  date = {2012},
  author = {van der Walt, P. D.},
  options = {useprefix=true},
  file = {/Users/doisinkidney/Zotero/storage/X358AMNW/van der Walt - 2012 - Reflection in Agda.pdf;/Users/doisinkidney/Zotero/storage/8ZQY4FCH/256628.html}
}


